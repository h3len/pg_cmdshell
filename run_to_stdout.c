//allows the execution of a shell command and the redirection of the stdout to an array
#include <string.h>
#include "postgres.h"
#include "fmgr.h"
#include "funcapi.h"

#define MAX_LINE_LENGTH 256

typedef struct {
	char * temp_filename;     //name of a temp file where command's output will be written and read
	HANDLE file_output;       //handle for writing to temp file
	HANDLE file_output_read;  //handle for reading to temp file
	PROCESS_INFORMATION pi;   //process that will be hosting the command
} execution_details;

//replace unwanted char with char that are displayed in postgresql
void replace_unwanted_char(char * file_buffer){
	for (int i = 0; i < MAX_LINE_LENGTH; i++){
		if (file_buffer[i] == '\n'){
			memmove(file_buffer + i, file_buffer + i + 1, MAX_LINE_LENGTH - i - 1);
		}
		else if (file_buffer[i] > 127 || file_buffer[i] < 0){
			file_buffer[i] = 32;
		}
	}
}

//Prepare the command line with information from COMSPEC environment variable ( = "Where is cmd.exe")
//or just the initial_command_line if use_cmd_exe = false
void prepare_command_line(char * command_to_run, char * initial_command_line, BOOL use_cmd_exe)
{
	if (use_cmd_exe) {
		strcpy(command_to_run, getenv("comspec"));
		strcat(command_to_run, " /c ");
	}
	strcat(command_to_run, initial_command_line);
}

//get a temp filename generated by os
char * get_temp_filename(){
	char temp_folder[MAX_PATH];
	char * temp_filename = palloc(sizeof(char) * MAX_PATH);
	GetTempPath(sizeof(temp_folder), temp_folder);
	GetTempFileName(temp_folder, "tmp", 0, temp_filename);
	return temp_filename;
}


//initialize file for output
BOOL initialize_files(execution_details * details){

	SECURITY_ATTRIBUTES security_attributes;
	ZeroMemory(&security_attributes, sizeof(security_attributes));
	security_attributes.nLength = sizeof(security_attributes);
	security_attributes.bInheritHandle = TRUE;

	details->temp_filename = get_temp_filename();

	// setup redirection handles
	// output handle must be WRITE mode, share READ
	// redirect handle must be READ mode, share WRITE
	details->file_output = INVALID_HANDLE_VALUE;
	details->file_output = CreateFile(details->temp_filename, GENERIC_WRITE, FILE_SHARE_READ, &security_attributes, CREATE_ALWAYS, FILE_ATTRIBUTE_TEMPORARY, 0);

	if (details->file_output == INVALID_HANDLE_VALUE) {
		return FALSE;
	}

	details->file_output_read = INVALID_HANDLE_VALUE;
	details->file_output_read = CreateFile(details->temp_filename, GENERIC_READ, FILE_SHARE_WRITE, 0, OPEN_EXISTING, 0, 0);

	if (details->file_output_read == INVALID_HANDLE_VALUE) {
		CloseHandle(details->file_output);
		return FALSE;
	}
	return TRUE;
}

BOOL execute_process(execution_details * details, char * command_line){
	//based on work from Hector Santos

	STARTUPINFO startup_info;
	ZeroMemory(&startup_info, sizeof(startup_info));
	startup_info.cb = sizeof(startup_info);
	if (details->file_output != INVALID_HANDLE_VALUE) {
		startup_info.dwFlags |= STARTF_USESTDHANDLES;
		startup_info.hStdOutput = details->file_output;
		startup_info.hStdError = details->file_output;
		startup_info.wShowWindow = SW_HIDE;
	}

	PROCESS_INFORMATION pi;
	ZeroMemory(&pi, sizeof(pi));
	details->pi = pi;

	DWORD dwFlags = CREATE_NO_WINDOW;  // NT/2000 only

	if (!CreateProcess(NULL, (char *)command_line, NULL, NULL, TRUE, dwFlags, NULL, NULL, &startup_info, &pi)) {

		int err = GetLastError();  // preserve the CreateProcess error

		if (details->file_output != INVALID_HANDLE_VALUE) {
			CloseHandle(details->file_output);
			CloseHandle(details->file_output_read);
		}

		SetLastError(err);
		return FALSE;
	}

	CloseHandle(pi.hThread);

	// wait for process to finish
	do {
		Sleep(1);
	} while (WaitForSingleObject(pi.hProcess, 0) != WAIT_OBJECT_0);

	return TRUE;
}

int extract_result(execution_details * details, char *** results){
	char** temp_result = NULL;
	temp_result = palloc(1 * sizeof(*temp_result));

	long result_count = 0;

	char empty_buffer[MAX_LINE_LENGTH] = { 0 };
	char file_buffer[MAX_LINE_LENGTH] = { 0 };
	char line_buffer[MAX_LINE_LENGTH] = { 0 };
	int line_buffer_char_count = 0;

	DWORD read_bytes_count;

	while (ReadFile(details->file_output_read, &file_buffer, sizeof(file_buffer) - 1, &read_bytes_count, NULL)) {

		if (read_bytes_count == 0) break;

		replace_unwanted_char(file_buffer);

		int file_buffer_length = (int)strlen(file_buffer);

		for (int i = 0; i < file_buffer_length; i++){

			if (file_buffer[i] != '\r' && line_buffer_char_count <= 255){
				//while interesting char are found, they are added to the line buffer
				line_buffer[line_buffer_char_count] = file_buffer[i];
				line_buffer_char_count++;
			}
			else{
				//new line. Add current line_buffer to the result array
				result_count++;
				line_buffer_char_count++;
				temp_result = repalloc(temp_result, result_count * sizeof(*temp_result));
				temp_result[result_count - 1] = palloc(line_buffer_char_count * sizeof(char));
				memcpy(temp_result[result_count - 1], line_buffer, line_buffer_char_count);

				//reset line_buffer
				line_buffer_char_count = 0;
				memcpy(line_buffer, empty_buffer, MAX_LINE_LENGTH);
			}
		}
		//reset file buffer
		memcpy(file_buffer, empty_buffer, MAX_LINE_LENGTH);
	}

	//if they're still some char left, add them as a new line
	if (line_buffer_char_count != 0){
		result_count++;
		temp_result = repalloc(temp_result, result_count * sizeof(*temp_result));
		temp_result[result_count - 1] = palloc(line_buffer_char_count * sizeof(char));
		memcpy(temp_result[result_count - 1], line_buffer, line_buffer_char_count - 1);
		line_buffer_char_count = 0;
	}

	*results = temp_result;
	return result_count;

}


void close_handles(execution_details * details){
	WaitForSingleObject(details->pi.hProcess, INFINITE);
	CloseHandle(details->pi.hProcess);
	CloseHandle(details->file_output);
	CloseHandle(details->file_output_read);
}

int exec_with_redirect_from_stdout(char *command_line, BOOL use_cmd_exe, char *** results)
{
	execution_details * details = (execution_details *)palloc(sizeof(execution_details));

	if (!initialize_files(details)) return FALSE;

	// use the current OS comspec for DOS commands, i.e., DIR
	char cmd[MAX_PATH] = { 0 };

	prepare_command_line(cmd, command_line, use_cmd_exe);

	if (!execute_process(details, cmd)) return FALSE;

	int result_count = extract_result(details, results);

	close_handles(details);

	DeleteFile(details->temp_filename);

	pfree(details);

	return result_count;

}
